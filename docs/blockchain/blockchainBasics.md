# Blockchain basics

## Hashes, Nonces & Mining

A hash is a fingerprint of digital data.

In crypto, the hash is normally set to a certain difficulty, e.g. for mining the block, you have to find a hash for the block that starts with 4 zero's (the more zeros the more difficult it is to find), the miner will iterate over the nonce number to find a value that fits with the rest of the blocks data, so that when the hash of the whole block is taken, it starts with 4 zeros.
The miner that finds this value first is normally rewarded with a small bit of crypto.

## Maintaining chain heritage (Democracy!)

Because each blocks data contains the hash of the previous block,
if a previous block is changed, it will change the hash of that block and therefore the `previous hash` value in the next block after it will change, this will in turn cause the hash value of that block to change too (and therefore not meet the conditions), and all blocks going ahead.

For someone to try to change the value of a blockchain in the middle of the chain, they will have to compute all the blocks going forward too, this will make the chain look valid. However there are some reasons this is not feasible.

1. Blockchain works as a distributed trust system which means the chain that is considered the truth is the one that is the longest + most common amongst the network.
2. To meet the above conditions, one will have to own 51%+ of the network so they can have the most _common_ chain and also this is super computationally expensive as they would have to be mining all the blocks going forward on their 51% owned network to keep up the facade.

## PublicKeys, Private Keys & Verification

With public and private keys you can sign messages and people can verify that it was you who signed them.

When you write a message you can use your `private key` to sign it.
This will in turn create a message signature, which will be a unique string that is generated based on the message you signed + the private key you signed it with.

`PrivateKey(Message) = messageSignature`

The public key of the person who signed the message is available to all users, along with the message signature. Using these + the message, anyone can verify that the Data that has been sent, was generated by the person that held the private key.

Using the public key of the person & the signature, any user can verify if the message has been signed by the person holding the private key, the function will only return true/false.

`PublicKey&Signature(Message) = True/False`

## The makeup of a block

### How transactions enter a block

Before moving onto how PoW works, its important to understand what makes up a block and how they run.

Blocks are created by the miners of the network, here's how.

1. **Transaction propagation** When a user initiates a transaction, they send the data to the network. These transactions are broadcasted to the nodes (computers) in the network.

2. **Transaction Validation** Nodes in the network receive transactions and verify their validity by checking factors such as if the user has sufficient funds, if the formatting is correct, if it includes the correct digital signature.

3. **Transaction Pool** Those transactions are then added to a place called the `transaction pool` or sometimes `metapool`. This pool is formed of transactions that are still pending & therefore not included in any blocks.

4. **Block Formation** Miners then periodically pick up transactions from the pool and group them into blocks. They typically prioritise transactions based on things such as transaction fees, transaction size, age of transaction etc.

5. **Proof of Work** Once a miner has selected transactions to be included in a block they begin trying to find a valid block hash using the `Proof of Work` algorithm, which involves repeatedly hashing the blocks header with a nonce and adding iterating the nonce value till it finds a valid hash that meets the difficulty level.

6. **Block Addition** Once the miner finds a valid block hash, they broadcast the block to the network. Other nodes in the network validate the block and, if it is deemed valid by the majority of the network, the transactions included in the block are considered confirmed as the block is added to the chain which is immutable.

### Elements of a Block

#### Block header

The block header consists of the following things:
`Version number` of the blockchain protocol being used, allowing for upgrades and improvements to the protocol over time.

`Previous Block Hash` which allows it to link to the previous block.

`Merkle Root` which is a hash of all transactions included in the block, it provides an efficient way to verify the integrity of all the transactions in the block.

`Timestamp` which records the time at which the block was created.

`Difficulty target` which represents current difficulty level for mining the block.

`Nonce` - the value in which the miners vary to find a valid hash for the Proof of work step.

#### Block body

The block body contains all the transactions in the block, it may also contain the full merkle tree.

## Proof of work

The proof of work is defined as a blockchain concencus mechanism which uses computing power to verify crypto transactions and add them to the blockchain.

In essence miners compete with each other to add a block to a blockchain, and they compete by trying to be the first to find a solution to a computationally intensive problem that has been broadcasted to the network. The first miner to solve this problem gets to add the block to the chain and the other nodes on the network can verify that it is a valid solution and therefore can confirm that the chain with the new block on it is the valid chain as long as the majority of nodes agree.

### How proof of work algorithm tends to work

The first thing you need to know about this concept is that a `block` tends to be made out of a few things, the `data` which tends to hold the transactions, the `previous hash` of the last block and a value called a `nonce`
